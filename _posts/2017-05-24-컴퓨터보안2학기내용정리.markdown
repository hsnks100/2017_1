---
layout: post
tags: 
title2: 컴퓨터보안 기말고사 정리
author: 코딩도사(hsnks100@gmail.com)
comments: true
---

# RSA 

전통적인 암호화는 하나의 키를 썼다. 그래서 sender 와 receiver 가 같은 키를 공유했다.  키 분배 문제가 생긴다. 
공개키 알고리즘은 Discrete log 의 어려움을 이용한다. 

비밀키와 공개키 두가지 개념이 있다. 기본적인 흐름은 다음과 같다.

1. A가  B에게 메세지를 보내기 위해서 B의 공개키로 A 가 메세지를 암호화 해서 보낸다.  
2. 이 메세지를 푸는건 B의 비밀키로만 풀 수 있다.  

신원 확인  

A->B 로 보낼 때, B 가 A 가 진짜로 보내는지 확인을 하기 위해서 필요한 절차  


1. A 는 A의 비밀키로 서명을 한다.  
2. B 는 받은 서명 데이터를 A의 공개키로 풀어본다. A 의 신분을 확인한다.  

1. 신원 확인을 위해서 나는 나의 비밀키로 서명을 한다. 서명한 데이터는 나의 공개키로만 풀 수 있다. 그래서 나의 신분을 상대방들이 확인할 수 있다.  

RSA 의 구체적인 방법은

$$
먼저 두 소수를 선택한다. p = 17, q = 11 \\ 
n = pq = 18 \\ 
\phi(n) = (p-1)(q-1) = 16 * 10 = 160 \\
gcd(e, 160)\; =\; \text{1 인 e 를 구한다. e = 7} \\
\text{de = 1 mod 160 인 d 를 구한다. d = 23
공개키는 {7, 187} 
비밀키는 {23, 17, 11}
}

$$

이제 암호화와 복호화를 살펴보면

$$
C = M^e\; mod\; n \\
M = C^d\; mod\; n \\


$$



# Key Management
키 관리에 대한 내용이다. 4가지 유형이 있다.


## public annoucement
게시판 같은곳에 올려버리는 방법.  광범위하게 배포하기 때문에 접근이 용이하며 편하다. 하지만 누군가 위장을 하는 취약점이 있다.

## publicly available directory
알려져있는 공간에 올리는 방법.   
뭔지 잘 모르겠다.



## public-key autority
어떤 기관이 관리
public-key 를 관리하는 중앙 센터가 있다. 기관은 각 개인의 비밀키를 알기 때문에 신원 확인이 가능하며 공개키 교환을 할 수 있다.  
하지만 이 방법또한 완벽하지 않은데, 시스템이 병목현상이 일어날 수 있다.

절차  
$$
(1) A는 B의 공개키를 요구함\\
(2) 기관은 A 에게 기관의 개인키로 Pu_b, Time_1 을 암호화 해서 전송한다.\\
(3) A 는 Pu_b 로 ID_A와 N_1 을 암호화해서 B에게 보낸다.\\
(4) B 는 기관으로부터 A의 공개키 PU_a를 얻는다.\\
...\\
(6) B 는 PU_a 로 N_1, N_2 를 A 에게 보낸다. (이 시점에서 A는 B임을 확인)\\
(7) A 는 PU_b 로 N_2 를 B에게 보낸다. (이 시점에서 A의 신원 확인)\\ 
$$


## public-key certificates
중요함!!  
인증서 (한국에서 쓰는 방식)  
공개키 인증서에 포함되는 내용{이름, 소속, 메일, 개인정보, 그 사람의 공개키}  
인증기관의 개인키로 디지털 서명이 되어있음.  
인증기관이 "이 공개키는 확실히 이 사람의 것이다." 라고 인정하는 수단  
인증 기관은 디지털 인증서를 발급할 수 있는 권한을 가진 기관이다.  

누군가 A 가 A 임을 확인하고 싶다면, A 의 인증서를 가지고 인증기관에 인증 요청을 보낸다.  

절차
$$
각 가입자 A, B 는 인증기관에 자신의 공개키를 제공하면서 인증서(C_A, C_B) 받음\\
A, B가 서로 확인하고 싶다면 서로에게 자신의 인증서를 보낸다.\\
이 인증서는 기관의 개인키로 암호화됐기 때문에, 풀수 있고 서로 신원을 확인할 수 있다.\\ 
$$

서로 인증이 되었다면, 이제 둘만의 인증을 위해 별도의 세션키를 가질 수 있다. 그 방법은 아래에서 설명한다.  


## Simple Secret Key distribution

Merkle 방법인데,  
이 방법은 A 가 공개키, 비밀키를 생성한다.
A 가 B 에게 공개키를 보낸다. B 는 둘만이 가지는 세션키 $$K_S$$ 를 제공된 A의 공개키로 암호화해서 보낸다.

하지만 이 방법은 Man-in-the-middle-attack 에 취약하다.  

## Secret Key Distribution with Confidentiality and Authentication
위의 방법에서 보완된 방법이다.
$$
가정, 서로가 풀 수 있는 상대방의 공개키로 보낸다.\\
A->B : N_1, ID_A 를 암호화해서 보낸다.\\
B->A : N_1, N_2 를 암호화해서 보낸다.\\ 
A->B : N_2 를 보낸다.\\
$$

위 과정에서 A 는 B 는 상호 인증된다. 마지막으로,  
$$
A->B : E(PU_b, E(PR_a, K_s)) 를 보낸다.  
$$

여기서 의문 : $$E(PU_b, K_s)$$ 만 보내면 될거 같은데 굳이 $$PR_a$$ 로 암호화해서 보내는 이유가??



## Hybrid Key Distribution

# Diffie-Hellman Key Exchange
무선 네트워크에서 주로 사용하는 방법이다.  
참고 사이트  
<http://moaimoai.tistory.com/86>  
<http://ezbeat.tistory.com/334>  

비밀키 : 일반적인 암호화에 사용되는 키. A와 B는 같은 비밀키를 공유해야 한다.  
공개키 : 공개키 알고리즘에서 사용되는 키로 외부에 공개되는 키  
개인키 : 공개키 알고리즘에서 사용되는 키로 개인이 소유하며 외부에 알려주지 않는 키  

$$
A의\;비밀키 = A의\;개인키[DH연산] B의공개키\\
B의\;비밀키 = B의\;개인키[DH연산] A의공개키\\
A의\;비밀키 = B의\;비밀키\\ 
$$

DH 는 위와 같은 수식이 성립한다. 즉, 서로의 공개키를 주고 받는것으로만 서로의 비밀키를 생성할 수 있다는 뜻.  


```
p 는 소수다.(>=1024 bits)
g 는 generator
s 는 비밀키
```

$$
K_{AB} : A, B 의 비밀키\\
y_A : A 의 공개키\\
y_B : B 의 공개키\\
x_A : A 의 비밀키\\
x_B : B 의 비밀키\\
$$

$$
y_A = g\;^{x_A}\;mod\;p\\
y_B = g\;^{x_B}\;mod\;p\\
K_{AB} = y_A\;^{x_B}\;mod\;q\\
K_{AB} = y_B\;^{x_A}\;mod\;q\\
$$

# ElGamal Cryptography
<http://reinliebe.tistory.com/26>  

엘가말 또한, 이산로그의 어려움을 이용한다.  

전제 과정

소수 q, 생성자 a, 비밀키 $$X_A (1 <= X_A <= q-1) $$  를 선택한다.  
랜덤수 $$ 1 <= k <= q-1 $$ 인 $$k$$ 를 선택한다.  
공개키 $$ Y_A = a^{X_A} $$ 를 계산한다.

-------------------------

B->A 로 전송하기 위해 

$$ 0 <= M <= q-1 $$ 인 메세지에 대해, $$ 1 <= k <=q-1 $$ 인
k 를 선택한다.  
onetime-key $$ K = Y_A\;^{k} $$ 를 계산한다.  

$$ 
C_1 = a^k \\
C_2 = KM \\ 
$$

이제 A 는 전송받은 $$ C_1, C_2 $$ 에 대해 K 를 복구 할 수 있다.

$$
K = C_1\;^{X_A} \\
M = C_2 K^{-1} \\
$$ 


# ECC(Elliptic Curve Cryptography)

$$ y^2 = x^3 + ax + b $$ 인 cubic elliptic curve of form 에서 마지막의 $$ mod\;p $$ 만 추가한 형태를 쓰게 된다.  

![image](https://cloud.githubusercontent.com/assets/3623889/26527393/439f5a7c-43ce-11e7-9d87-46da478077b5.png)

$$ P3 = P1 + P2 $$ 연산을 정의해야 하는데, 그 정의는 P1, P2 를 잇는 선의 연장선과 곡선의 교점을 Q 라 할 때, Q 랑 x 축의 반대쪽에 있는 점이 P3.  

항상 P3 가 존재하기 위해서는 $$ 4a^3 + 27b^2 \ne 0 $$ 이어야 한다.  

$$ P+(-P) = O, 2P = R(y \ne 0), 2P = O (y = 0) $$

$$ When P = (X_p, Y_p), Q = (X_Q, Y_Q) and P \ne Q, P \ne -Q) $$

덧셈 정의
$$ R = (s^2 - X_P - X_Q, s(X_P - X_R) - Y_P), \\
s = {(Y_P - Y_Q) \over {X_P - X_Q}} $$

2P 정의  
$$ Y_P\; is\; not\; O, \\
2P = (s^2 - 2X_P, s(X_P - X_R) - Y_P) \\
s = {(3{X_P}^2 + a) \over (2Y_P) }\\
$$

덧셈 정의 증명

$$
PQ 선은 y = k(x-x_1)+y_1 로 나타낼 수 있다.  \\
EC equation : y^2 = x^3 + ax + b 에 대입하면 \\
x^3 - k^2 x^2 + ... 을 얻는다. \\
일반적으로 ax^3 + bx^2 + cx + d = 0 의 세근을 \alpha, \beta, \gamma 라고 하면 \\
\alpha + \beta + \gamma = -{ b \over a} \\

x_1 + x_2 + x_3 = k^2 \\
thus, x_3 = k^2 - (x_1 + x_2) \\
-y_3 = k(x_3 - x_1) + y_1 \\
y_3 = k(x_1 - x_3) - y_1 \\ 
$$

$$

y^2 = x^3 + 2x + 3 \;(mod 5)\\
곡선위의 \;점들은\;아래와\;같다.
(1,1), (1,4), (2,0), (3,1), (3,4), (4,0)\\ 
\\

\text{위에서 다음과 같이 정의했다.}\\
R = (s^2 - X_P - X_Q, s(X_P - X_R) - Y_P) \; mod\; q, \\
s = (Y_P - Y_Q) * {X_P - X_Q} ^-1 mod\; q \\
\text{(1, 4) + (3, 1) 에 대해 살펴본다.} \\
s = (4-1) * (1-3)^{-1} = 3 * (-2)^{-1} = 3 * 3^{-1} = 3*2 = 6 = 1\\
x_3 = (1^2 - 1 - 3) = 2 \\
y_3 = 1(1 - 2) - 4 = -5 = 0 \\
\text{즉, } (2, 0) \\ 

$$


## Why ECC?
key-size 가 작다. RSA 나 다른 알고리즘에 비해서 보안성이 떨어지지 않는다. 

## Diffie Hellman over ECC

위에서 정의한 ECC 연산을 바탕으로 Diffie Hellman 을 생각할 수 있다.

<http://ezbeat.tistory.com/336 > 

# Message Authentication & Hash Functions

# Message Authentication Codes

# Birthday Attacks

# Classification of Hash Functions

# MAC vs. MIC

# Unkeyed Hash Functions

# Secure Hash Algorithm

# Keyed Hash Functions

# HMAC

# Digital Signatures

# Properties

# Attacks and Forgeries

# Direct Digital Signature

# ElGamal Digital Signature Scheme

# Schnorr Digital Signature Scheme

# Digial Signature Standard

# X.509 Certificates & PKI

# X.509 Certification Service

# Public Key Infstructure


# needham-schroeder protocol
등장 A, B, KDC

A 가 KDC 에게 B랑 통신하고 싶다고 함.
KdC 는 A한테 Ka (A의 비밀키) 로 암호화 해서 Ks, IDb, N1, Ekb[Ks, IDa] 를 보냄.
Ekb[Ks, IDa] 는 A 가 못 품.
이 Ekb[Ks, IDa] 를 A가 B 에게 보냄.
이제 서로 Ks 세션키를 가지게 됨.
B가 A에게 Ks 로 N2 를 암호화 해서 보냄
A는 B에게 f(N2) 을 보내서 서로 확인함.


